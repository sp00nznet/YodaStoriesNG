using Hexa.NET.SDL2;

namespace YodaStoriesNG.Engine.Rendering;

/// <summary>
/// Simple 8x8 bitmap font for text rendering.
/// Uses a built-in font based on the classic IBM PC font.
/// </summary>
public unsafe class BitmapFont : IDisposable
{
    private SDLTexture* _fontTexture;
    private const int CharWidth = 8;
    private const int CharHeight = 8;
    private const int CharsPerRow = 16;
    private const int FirstChar = 32; // Space
    private const int LastChar = 126; // Tilde

    // 8x8 font bitmap data for ASCII 32-126 (space to tilde)
    // Each character is 8 bytes (8 rows of 8 bits each)
    private static readonly byte[][] FontData = new byte[][]
    {
        // Space (32)
        new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
        // ! (33)
        new byte[] { 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00 },
        // " (34)
        new byte[] { 0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 },
        // # (35)
        new byte[] { 0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00 },
        // $ (36)
        new byte[] { 0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00 },
        // % (37)
        new byte[] { 0x00, 0x66, 0xAC, 0xD8, 0x36, 0x6A, 0xCC, 0x00 },
        // & (38)
        new byte[] { 0x38, 0x6C, 0x68, 0x76, 0xDC, 0xCE, 0x7B, 0x00 },
        // ' (39)
        new byte[] { 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00 },
        // ( (40)
        new byte[] { 0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00 },
        // ) (41)
        new byte[] { 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00 },
        // * (42)
        new byte[] { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00 },
        // + (43)
        new byte[] { 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00 },
        // , (44)
        new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30 },
        // - (45)
        new byte[] { 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00 },
        // . (46)
        new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00 },
        // / (47)
        new byte[] { 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00 },
        // 0 (48)
        new byte[] { 0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00 },
        // 1 (49)
        new byte[] { 0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00 },
        // 2 (50)
        new byte[] { 0x3C, 0x66, 0x06, 0x1C, 0x30, 0x66, 0x7E, 0x00 },
        // 3 (51)
        new byte[] { 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00 },
        // 4 (52)
        new byte[] { 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00 },
        // 5 (53)
        new byte[] { 0x7E, 0x62, 0x60, 0x7C, 0x06, 0x66, 0x3C, 0x00 },
        // 6 (54)
        new byte[] { 0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00 },
        // 7 (55)
        new byte[] { 0x7E, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x00 },
        // 8 (56)
        new byte[] { 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00 },
        // 9 (57)
        new byte[] { 0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00 },
        // : (58)
        new byte[] { 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00 },
        // ; (59)
        new byte[] { 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30 },
        // < (60)
        new byte[] { 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00 },
        // = (61)
        new byte[] { 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00 },
        // > (62)
        new byte[] { 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00 },
        // ? (63)
        new byte[] { 0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00 },
        // @ (64)
        new byte[] { 0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7E, 0x00 },
        // A (65)
        new byte[] { 0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00 },
        // B (66)
        new byte[] { 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00 },
        // C (67)
        new byte[] { 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00 },
        // D (68)
        new byte[] { 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00 },
        // E (69)
        new byte[] { 0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00 },
        // F (70)
        new byte[] { 0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00 },
        // G (71)
        new byte[] { 0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00 },
        // H (72)
        new byte[] { 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00 },
        // I (73)
        new byte[] { 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00 },
        // J (74)
        new byte[] { 0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00 },
        // K (75)
        new byte[] { 0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00 },
        // L (76)
        new byte[] { 0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00 },
        // M (77)
        new byte[] { 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00 },
        // N (78)
        new byte[] { 0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00 },
        // O (79)
        new byte[] { 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00 },
        // P (80)
        new byte[] { 0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00 },
        // Q (81)
        new byte[] { 0x38, 0x6C, 0xC6, 0xC6, 0xDA, 0xCC, 0x76, 0x00 },
        // R (82)
        new byte[] { 0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00 },
        // S (83)
        new byte[] { 0x3C, 0x66, 0x70, 0x38, 0x0E, 0x66, 0x3C, 0x00 },
        // T (84)
        new byte[] { 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00 },
        // U (85)
        new byte[] { 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00 },
        // V (86)
        new byte[] { 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00 },
        // W (87)
        new byte[] { 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00 },
        // X (88)
        new byte[] { 0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00 },
        // Y (89)
        new byte[] { 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00 },
        // Z (90)
        new byte[] { 0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00 },
        // [ (91)
        new byte[] { 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00 },
        // \ (92)
        new byte[] { 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00 },
        // ] (93)
        new byte[] { 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00 },
        // ^ (94)
        new byte[] { 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00 },
        // _ (95)
        new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE },
        // ` (96)
        new byte[] { 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00 },
        // a (97)
        new byte[] { 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3B, 0x00 },
        // b (98)
        new byte[] { 0x70, 0x30, 0x3E, 0x33, 0x33, 0x33, 0x6E, 0x00 },
        // c (99)
        new byte[] { 0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00 },
        // d (100)
        new byte[] { 0x0E, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3B, 0x00 },
        // e (101)
        new byte[] { 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00 },
        // f (102)
        new byte[] { 0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00 },
        // g (103)
        new byte[] { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x7C },
        // h (104)
        new byte[] { 0x70, 0x30, 0x36, 0x3B, 0x33, 0x33, 0x73, 0x00 },
        // i (105)
        new byte[] { 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00 },
        // j (106)
        new byte[] { 0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C },
        // k (107)
        new byte[] { 0x70, 0x30, 0x33, 0x36, 0x3C, 0x36, 0x73, 0x00 },
        // l (108)
        new byte[] { 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00 },
        // m (109)
        new byte[] { 0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00 },
        // n (110)
        new byte[] { 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00 },
        // o (111)
        new byte[] { 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00 },
        // p (112)
        new byte[] { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78 },
        // q (113)
        new byte[] { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F },
        // r (114)
        new byte[] { 0x00, 0x00, 0x6E, 0x3B, 0x33, 0x30, 0x78, 0x00 },
        // s (115)
        new byte[] { 0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00 },
        // t (116)
        new byte[] { 0x08, 0x18, 0x3E, 0x18, 0x18, 0x1A, 0x0C, 0x00 },
        // u (117)
        new byte[] { 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3B, 0x00 },
        // v (118)
        new byte[] { 0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00 },
        // w (119)
        new byte[] { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00 },
        // x (120)
        new byte[] { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00 },
        // y (121)
        new byte[] { 0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x7C },
        // z (122)
        new byte[] { 0x00, 0x00, 0x7E, 0x4C, 0x18, 0x32, 0x7E, 0x00 },
        // { (123)
        new byte[] { 0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00 },
        // | (124)
        new byte[] { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00 },
        // } (125)
        new byte[] { 0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00 },
        // ~ (126)
        new byte[] { 0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    };

    public bool Initialize(SDLRenderer* renderer)
    {
        // Create font texture (16x6 characters = 128x48 pixels)
        int textureWidth = CharsPerRow * CharWidth;
        int textureHeight = ((LastChar - FirstChar + 1) / CharsPerRow + 1) * CharHeight;

        _fontTexture = SDL.CreateTexture(
            renderer,
            (uint)SDLPixelFormatEnum.Argb8888,
            (int)SDLTextureAccess.Static,
            textureWidth,
            textureHeight);

        if (_fontTexture == null)
        {
            Console.WriteLine($"Failed to create font texture: {SDL.GetErrorS()}");
            return false;
        }

        SDL.SetTextureBlendMode(_fontTexture, SDLBlendMode.Blend);

        // Generate texture pixels
        var pixels = new uint[textureWidth * textureHeight];

        for (int charIndex = 0; charIndex < FontData.Length; charIndex++)
        {
            int charX = (charIndex % CharsPerRow) * CharWidth;
            int charY = (charIndex / CharsPerRow) * CharHeight;

            var charData = FontData[charIndex];
            for (int row = 0; row < CharHeight; row++)
            {
                byte rowBits = charData[row];
                for (int col = 0; col < CharWidth; col++)
                {
                    bool isSet = (rowBits & (0x80 >> col)) != 0;
                    int pixelX = charX + col;
                    int pixelY = charY + row;
                    pixels[pixelY * textureWidth + pixelX] = isSet ? 0xFFFFFFFF : 0x00000000;
                }
            }
        }

        // Upload to texture
        fixed (uint* pixelPtr = pixels)
        {
            SDL.UpdateTexture(_fontTexture, null, pixelPtr, textureWidth * 4);
        }

        return true;
    }

    public void RenderText(SDLRenderer* renderer, string text, int x, int y, int scale = 1,
        byte r = 255, byte g = 255, byte b = 255, byte a = 255)
    {
        if (_fontTexture == null || string.IsNullOrEmpty(text))
            return;

        SDL.SetTextureColorMod(_fontTexture, r, g, b);
        SDL.SetTextureAlphaMod(_fontTexture, a);

        int cursorX = x;
        foreach (char c in text)
        {
            if (c == '\n')
            {
                cursorX = x;
                y += CharHeight * scale;
                continue;
            }

            if (c >= FirstChar && c <= LastChar)
            {
                int charIndex = c - FirstChar;
                int srcX = (charIndex % CharsPerRow) * CharWidth;
                int srcY = (charIndex / CharsPerRow) * CharHeight;

                var srcRect = new SDLRect { X = srcX, Y = srcY, W = CharWidth, H = CharHeight };
                var dstRect = new SDLRect { X = cursorX, Y = y, W = CharWidth * scale, H = CharHeight * scale };

                SDL.RenderCopy(renderer, _fontTexture, &srcRect, &dstRect);
            }

            cursorX += CharWidth * scale;
        }
    }

    public int GetTextWidth(string text, int scale = 1)
    {
        if (string.IsNullOrEmpty(text))
            return 0;
        return text.Length * CharWidth * scale;
    }

    public int GetTextHeight(int scale = 1)
    {
        return CharHeight * scale;
    }

    public void Dispose()
    {
        if (_fontTexture != null)
        {
            SDL.DestroyTexture(_fontTexture);
            _fontTexture = null;
        }
    }
}
